/* Generated By:JavaCC: Do not edit this line. FieldValueExpressionParser.java */
package com.jm.wf.events.expressions.parsers;

import com.jm.wf.common.datavalues.DataValue;
import com.jm.wf.common.datavalues.DataValueFactory;
import com.jm.wf.common.datavalues.DataValueType;
import com.jm.wf.events.expressions.Expression;
import com.jm.wf.events.expressions.ExpressionBase;
import com.jm.wf.events.expressions.Factor;
import com.jm.wf.events.expressions.FieldValueExpression;
import com.jm.wf.events.expressions.LocalVariable;
import com.jm.wf.events.expressions.methods.MethodBase;
import com.jm.wf.events.expressions.operators.OperatorBase;
import com.jm.wf.events.expressions.operators.OperatorBitNot;
import com.jm.wf.events.expressions.operators.OperatorCast;
import com.jm.wf.events.expressions.operators.OperatorConditional;
import com.jm.wf.events.expressions.operators.OperatorLogNot;
import com.jm.wf.events.expressions.operators.OperatorUnaryMinus;
import com.jm.wf.events.expressions.operators.OperatorUnaryPlus;
import com.jm.wf.events.filters.FilterInterval;
import com.jm.wf.events.filters.FilterIntervalDegenerateBounded;
import com.jm.wf.events.filters.FilterIntervalNonDegenerateBounded;
import com.jm.wf.events.filters.FilterIntervalUnbounded;
import com.jm.wf.events.filters.FilterTemplate;
import com.jm.wf.events.filters.FilterTemplateField;
import com.jm.wf.events.filters.FilterTemplateSubField;

import java.io.InputStream;
import java.io.Reader;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.*;

/**
 * <h2>FieldValueExpressionParser</h2>
 * The Field Value Expression Parser is primarily intended to produce <b>FieldValueExpression</b>
 * objects to be used by Data Feed Adapters, the Source Event configuration and framework
 * components that wish to interact with source event data.
 * <p>
 * Field value expressions may contain <b>FilterTemplate</b> objects that are also useful outside
 * the context of a field value expression. And, in turn, the FilterTemplate may contain <b>FilterInterval</b>
 * objects as part of sub-fields. To allow creation of these objects the FieldValueExpression parser
 * exposes the corresponding production rules as entry points that are accessible through the
 * following static methods:</p>
 * <ul>
 * <li>Class&lt;? extends FilterTemplate&gt;.create()</li>
 * <li>FilterIntervalBase.create()</li>
 * </ul>
 */
public class FieldValueExpressionParser implements FieldValueExpressionParserConstants {
        protected Class<?> filterClass = null;
        protected Logger   logger      = null;

        protected FieldValueExpression fieldValueExpression = null;

        protected Map<String, LocalVariable> symbolTable = new HashMap<String, LocalVariable>();

        public FieldValueExpressionParser(Class<? extends FilterTemplate> filterClass,
                                          Logger                          logger,
                                          InputStream                     inputStream)
        {
                this(inputStream);

                this.filterClass = filterClass;
                this.logger      = logger;
        }

        public FieldValueExpressionParser(Class<?> filterClass,
                                          Logger   logger,
                                          Reader   reader)
        {
                this(reader);

                this.filterClass = filterClass;
                this.logger      = logger;
        }

  final public FieldValueExpression FieldValueExpression() throws ParseException {
        fieldValueExpression = new FieldValueExpression();

        List<ExpressionBase> expressions = null;
    expressions = Expressions();
                fieldValueExpression.setExpressions(expressions);

            {if (true) return fieldValueExpression;}
    throw new Error("Missing return statement in function");
  }

  final public List<ExpressionBase> Expressions() throws ParseException {
        List<ExpressionBase> result = new ArrayList<ExpressionBase>();

        ExpressionBase expression = null;
    expression = Expression();
                        result.add(expression);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEMI_COLON:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      jj_consume_token(SEMI_COLON);
      expression = Expression();
                            result.add(expression);
    }
                {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase Expression() throws ParseException {
        Token          varName    = null;
        ExpressionBase expression = null;
        ExpressionBase result     = null;
        ExpressionBase term       = null;
        OperatorBase operator   = null;
    label_2:
    while (true) {
      if (jj_2_1(2)) {
        ;
      } else {
        break label_2;
      }
      varName = jj_consume_token(VAR_NAME);
      operator = AssignOperator();
                        if (operator != null)
                        {
                                LocalVariable variable = null;

                                if ((variable = symbolTable.get(varName.image)) == null)
                                {
                                    variable = new LocalVariable(varName.image,
                                                                 fieldValueExpression);

                                    symbolTable.put(varName.image, variable);
                                }

                                Factor factor = new Factor();

                                factor.setVariable(variable);

                                operator.setLhs(factor);

                                if (result != null)
                                {
                                        ((OperatorBase) result).setRhs(operator);
                                }
                                else
                                {
                                        expression = operator;
                                }

                                result = operator;
                        }
    }
    term = CondTerm();
                if (operator != null)
                {
                        operator.setRhs(term);
                }
                else
                {
                        expression = term;
                }
                {if (true) return expression;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase CondTerm() throws ParseException {
        ExpressionBase result    = null;
        OperatorBase   operator  = null;
        ExpressionBase condTerm  = null;
        ExpressionBase termTrue  = null;
        ExpressionBase termFalse = null;
    condTerm = LogOrTerm();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COND_TRUE:
      jj_consume_token(COND_TRUE);
                        operator = new OperatorConditional();

                        ((OperatorConditional) operator).setCondition(condTerm);
      termTrue = CondTerm();
      jj_consume_token(COND_FALSE);
      termFalse = CondTerm();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
                if (operator != null)
                {
                    operator.setLhs(termTrue);
                    operator.setRhs(termFalse);

                    result = operator;
                }
                else
                {
                        result = condTerm;
                }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase LogOrTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = LogAndTerm();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOG_OR:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_3;
      }
      operator = LogOrOperator();
      term = LogAndTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase LogAndTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = BitOrTerm();
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOG_AND:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_4;
      }
      operator = LogAndOperator();
      term = BitOrTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase BitOrTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = BitXorTerm();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_OR:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_5;
      }
      operator = BitOrOperator();
      term = BitXorTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase BitXorTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = BitAndTerm();
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_XOR:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_6;
      }
      operator = BitXorOperator();
      term = BitAndTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase BitAndTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = LogEqTerm();
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BIT_AND:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_7;
      }
      operator = BitAndOperator();
      term = LogEqTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase LogEqTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = LogRelTerm();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOG_EQ:
    case LOG_NE:
      operator = LogEqOperator();
      term = LogRelTerm();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
                if (operator != null)
                {
                    operator.setLhs(result);
                    operator.setRhs(term);

                    result = operator;
                }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase LogRelTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = ShiftTerm();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOG_LT:
    case LOG_LTE:
    case LOG_GT:
    case LOG_GTE:
      operator = LogRelOperator();
      term = ShiftTerm();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
                if (operator != null)
                {
                    operator.setLhs(result);
                    operator.setRhs(term);

                    result = operator;
                }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase ShiftTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = AddTerm();
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
      case RSHIFT:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_8;
      }
      operator = ShiftOperator();
      term = AddTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase AddTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = MulTerm();
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_9;
      }
      operator = AddOperator();
      term = MulTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase MulTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    result = PowerTerm();
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLY:
      case DIVIDE:
      case MODULUS:
        ;
        break;
      default:
        jj_la1[11] = jj_gen;
        break label_10;
      }
      operator = MulOperator();
      term = PowerTerm();
                        if (operator != null)
                        {
                            operator.setLhs(result);
                            operator.setRhs(term);

                            result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase PowerTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term             = null;
    result = CastTerm();
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POWER:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_11;
      }
      operator = PowerOperator();
      term = CastTerm();
                                if (operator != null)
                        {
                                operator.setLhs(result);
                                operator.setRhs(term);

                                result = operator;
                        }
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase CastTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
        Token          typeName = null;
    if (jj_2_2(4)) {
      jj_consume_token(LPAREN);
      typeName = jj_consume_token(IDENTIFIER);
      jj_consume_token(RPAREN);
    } else {
      ;
    }
    term = UnaryTerm();
                if (typeName != null)
                {
                        operator = new OperatorCast();

                        ((OperatorCast) operator).setCastType(typeName.image);

                        operator.setRhs(term);

                        result = operator;
                }
                else
                {
                        result = term;
                }

            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase UnaryTerm() throws ParseException {
        ExpressionBase result   = null;
        OperatorBase   operator = null;
        ExpressionBase term     = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
    case MINUS:
    case BIT_NOT:
    case LOG_NOT:
      operator = UnaryOperator();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    term = MethodTerm();
                if (operator != null)
                {
                        operator.setRhs(term);

                        result = operator;
                }
                else
                {
                        result = term;
                }

            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase MethodTerm() throws ParseException {
        ExpressionBase result = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MTHD_NAME:
      result = MethodCall();
      break;
    case LPAREN:
    case INTEGER:
    case REAL:
    case HEXNUM:
    case IDENTIFIER:
    case VAR_NAME:
    case QSTRING_LITERAL:
      result = Factor();
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase MethodCall() throws ParseException {
        MethodBase     method    = null;
        ExpressionBase parameter = null;
    method = MethodName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
      case MINUS:
      case BIT_NOT:
      case LOG_NOT:
      case LPAREN:
      case INTEGER:
      case REAL:
      case HEXNUM:
      case IDENTIFIER:
      case VAR_NAME:
      case MTHD_NAME:
      case QSTRING_LITERAL:
        parameter = Expression();
                                if (method != null)
                                {
                                        method.addParameter(parameter);
                                }
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[15] = jj_gen;
            break label_12;
          }
          jj_consume_token(COMMA);
          parameter = Expression();
                                        if (method != null)
                                        {
                                                method.addParameter(parameter);
                                        }
        }
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
            {if (true) return method;}
    throw new Error("Missing return statement in function");
  }

  final public MethodBase MethodName() throws ParseException {
        Token methodName = null;
    methodName = jj_consume_token(MTHD_NAME);
        {if (true) return MethodBase.create(methodName.image.substring(1));}
    throw new Error("Missing return statement in function");
  }

  final public ExpressionBase Factor() throws ParseException {
        ExpressionBase result        = null;
        Factor         factor        = new Factor();
    ExpressionBase expression    = null;
    ExpressionBase subExpression = null;
        DataValue value         = null;
        FilterTemplate template      = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case REAL:
    case HEXNUM:
      value = Number();
                        factor.setValue(value);

                        result = factor;
      break;
    case QSTRING_LITERAL:
      token = jj_consume_token(QSTRING_LITERAL);
                        String str = token.image.substring(1, token.image.length()-1);

                    value = DataValueFactory.createDataValue(str,
                                                             DataValueType.eString);

                factor.setValue(value);

                result = factor;
      break;
    case VAR_NAME:
      token = jj_consume_token(VAR_NAME);
                LocalVariable variable = symbolTable.get(token.image);

                if (variable == null)
                {
                        // If the variable hasn't been defined then add it to the symbol table.

                            variable = new LocalVariable(token.image,
                                                         fieldValueExpression);

                            symbolTable.put(token.image, variable);
                }

                // This is a local variable so add it to the symbol cache.

                factor.setVariable(variable);

                result = factor;
      break;
    case IDENTIFIER:
      token = jj_consume_token(IDENTIFIER);
                    try
                    {
                    template = (FilterTemplate) filterClass.newInstance();

                    template = FilterTemplateFromName(template, token.image, logger);

                    factor.setTemplate(template);

                    result = factor;
                    }
                    catch (Exception e)
                    {
                        logger.error(e.getMessage());

                        {if (true) throw new ParseException(e.getMessage());}
                    }
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      subExpression = Expression();
      jj_consume_token(RPAREN);
                        expression = new Expression();

                        ((Expression) expression).setSubExpression(subExpression);

                        result = expression;
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            {if (true) return result;}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase PowerOperator() throws ParseException {
        Token op = null;
    op = jj_consume_token(POWER);
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase AddOperator() throws ParseException {
        Token op = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      op = jj_consume_token(PLUS);
      break;
    case MINUS:
      op = jj_consume_token(MINUS);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase AssignOperator() throws ParseException {
        Token op = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      op = jj_consume_token(ASSIGN);
      break;
    case PLUS_ASSIGN:
      op = jj_consume_token(PLUS_ASSIGN);
      break;
    case MINUS_ASSIGN:
      op = jj_consume_token(MINUS_ASSIGN);
      break;
    case MULT_ASSIGN:
      op = jj_consume_token(MULT_ASSIGN);
      break;
    case DIVIDE_ASSIGN:
      op = jj_consume_token(DIVIDE_ASSIGN);
      break;
    case MOD_ASSIGN:
      op = jj_consume_token(MOD_ASSIGN);
      break;
    case AND_ASSIGN:
      op = jj_consume_token(AND_ASSIGN);
      break;
    case OR_ASSIGN:
      op = jj_consume_token(OR_ASSIGN);
      break;
    case XOR_ASSIGN:
      op = jj_consume_token(XOR_ASSIGN);
      break;
    case LSHIFT_ASSIGN:
      op = jj_consume_token(LSHIFT_ASSIGN);
      break;
    case RSHIFT_ASSIGN:
      op = jj_consume_token(RSHIFT_ASSIGN);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase BitAndOperator() throws ParseException {
        Token op = null;
    op = jj_consume_token(BIT_AND);
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase BitOrOperator() throws ParseException {
        Token op = null;
    op = jj_consume_token(BIT_OR);
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase BitXorOperator() throws ParseException {
        Token op = null;
    op = jj_consume_token(BIT_XOR);
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase LogAndOperator() throws ParseException {
        Token op = null;
    op = jj_consume_token(LOG_AND);
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase LogEqOperator() throws ParseException {
        Token op = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOG_EQ:
      op = jj_consume_token(LOG_EQ);
      break;
    case LOG_NE:
      op = jj_consume_token(LOG_NE);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase LogOrOperator() throws ParseException {
        Token op = null;
    op = jj_consume_token(LOG_OR);
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase LogRelOperator() throws ParseException {
        Token op = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOG_LT:
      op = jj_consume_token(LOG_LT);
      break;
    case LOG_LTE:
      op = jj_consume_token(LOG_LTE);
      break;
    case LOG_GT:
      op = jj_consume_token(LOG_GT);
      break;
    case LOG_GTE:
      op = jj_consume_token(LOG_GTE);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase MulOperator() throws ParseException {
        Token op = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MULTIPLY:
      op = jj_consume_token(MULTIPLY);
      break;
    case DIVIDE:
      op = jj_consume_token(DIVIDE);
      break;
    case MODULUS:
      op = jj_consume_token(MODULUS);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase ShiftOperator() throws ParseException {
        Token op = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LSHIFT:
      op = jj_consume_token(LSHIFT);
      break;
    case RSHIFT:
      op = jj_consume_token(RSHIFT);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return OperatorBase.create(op.image);}
    throw new Error("Missing return statement in function");
  }

  final public OperatorBase UnaryOperator() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
                {if (true) return new OperatorUnaryPlus();}
      break;
    case MINUS:
      jj_consume_token(MINUS);
                {if (true) return new OperatorUnaryMinus();}
      break;
    case BIT_NOT:
      jj_consume_token(BIT_NOT);
                {if (true) return new OperatorBitNot();}
      break;
    case LOG_NOT:
      jj_consume_token(LOG_NOT);
                {if (true) return new OperatorLogNot();}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public DataValue Number() throws ParseException {
        Token     token = null;
        DataValue value = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      token = jj_consume_token(INTEGER);
                value = DataValueFactory.createDataValue(token.image,
                                                             DataValueType.eInteger);
      break;
    case REAL:
      token = jj_consume_token(REAL);
                value = DataValueFactory.createDataValue(token.image,
                                                             DataValueType.eReal);
      break;
    case HEXNUM:
      token = jj_consume_token(HEXNUM);
                    value = DataValueFactory.createDataValue(token.image,
                                                             DataValueType.eInteger);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

  final public FilterTemplate FilterTemplate(FilterTemplate template, Logger logger) throws ParseException {
    FilterTemplateField field = null;
    field = TemplateField(template, logger);
        template.addTemplateField(field);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLD_CAT:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_13;
      }
      jj_consume_token(FLD_CAT);
      field = TemplateField(template, logger);
            template.addTemplateField(field);
    }
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public FilterTemplate FilterTemplateFromName(FilterTemplate template, String fieldName, Logger logger) throws ParseException {
    FilterTemplateField field = null;
    field = NamedTemplateField(template, fieldName, logger);
        template.addTemplateField(field);
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLD_CAT:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_14;
      }
      jj_consume_token(FLD_CAT);
      field = TemplateField(template, logger);
            template.addTemplateField(field);
    }
        {if (true) return template;}
    throw new Error("Missing return statement in function");
  }

  final public FilterTemplateField TemplateField(FilterTemplate template, Logger logger) throws ParseException {
    String  fieldName   = "";
    boolean instantiate = true;
    boolean negate      = false;
    String  format      = "";

    FilterTemplateField field       = null;
    FilterTemplateSubField subField = null;
    instantiate = InstantiateField();
    fieldName = TemplateFieldName();
        try
        {
            field = template.createFilterTemplateField(fieldName);

            field.instantiateField(instantiate);
        }
        catch (Exception e)
        {
                {if (true) throw new ParseException("Field not supported: " + fieldName);}
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      format = FieldFormatString();
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[29] = jj_gen;
      ;
    }
        field.setFormatString(format);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      negate = NegateField();
                field.negateField(negate);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case IDENTIFIER:
      case QSTRING_LITERAL:
        subField = TemplateSubField(field, logger);
                    field.addSubField(subField);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[30] = jj_gen;
            break label_15;
          }
          jj_consume_token(COMMA);
          subField = TemplateSubField(field, logger);
                                field.addSubField(subField);
        }
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
        {if (true) return field;}
    throw new Error("Missing return statement in function");
  }

  final public FilterTemplateField NamedTemplateField(FilterTemplate template, String fieldName, Logger logger) throws ParseException {
    boolean instantiate = true;
    boolean negate      = false;
    String  format      = "";

    FilterTemplateField field       = null;
    FilterTemplateSubField subField = null;
        try
        {
            field = template.createFilterTemplateField(fieldName);

            field.instantiateField(instantiate);
        }
        catch (Exception e)
        {
                {if (true) throw new ParseException("Field not supported: " + fieldName);}
        }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      format = FieldFormatString();
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
        field.setFormatString(format);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      negate = NegateField();
                field.negateField(negate);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case IDENTIFIER:
      case QSTRING_LITERAL:
        subField = TemplateSubField(field, logger);
                    field.addSubField(subField);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[34] = jj_gen;
            break label_16;
          }
          jj_consume_token(COMMA);
          subField = TemplateSubField(field, logger);
                                field.addSubField(subField);
        }
        break;
      default:
        jj_la1[35] = jj_gen;
        ;
      }
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
        {if (true) return field;}
    throw new Error("Missing return statement in function");
  }

  final public String TemplateFieldName() throws ParseException {
        Token t;
    t = jj_consume_token(IDENTIFIER);
                {if (true) return t.image;}
    throw new Error("Missing return statement in function");
  }

  final public boolean InstantiateField() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BIT_NOT:
      jj_consume_token(BIT_NOT);
                {if (true) return false;}
      break;
    default:
      jj_la1[37] = jj_gen;
                {if (true) return true;}
    }
    throw new Error("Missing return statement in function");
  }

  final public boolean NegateField() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOG_NOT:
      jj_consume_token(LOG_NOT);
                {if (true) return true;}
      break;
    default:
      jj_la1[38] = jj_gen;
                {if (true) return false;}
    }
    throw new Error("Missing return statement in function");
  }

  final public String FieldFormatString() throws ParseException {
        Token t;
    t = jj_consume_token(QSTRING_LITERAL);
                {if (true) return t.image.substring(1, t.image.length()-1);}
    throw new Error("Missing return statement in function");
  }

  final public FilterTemplateSubField TemplateSubField(FilterTemplateField field, Logger logger) throws ParseException {
        FilterTemplateSubField subField = null;

        String str;

        FilterInterval interval = null;
    str = SubFieldGroupName();
        subField = field.createFilterTemplateSubField(str);
    jj_consume_token(LBRACE);
    if (jj_2_3(2)) {
      interval = FilterInterval(field.getFieldType());
                        try
                        {
                            subField.addSubFieldInterval(interval);
                        }
                        catch (Exception e)
                        {
                                {if (true) throw new ParseException(e.toString());}
                        }
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_17;
        }
        jj_consume_token(COMMA);
        interval = FilterInterval(field.getFieldType());
                        try
                        {
                            subField.addSubFieldInterval(interval);
                        }
                        catch (Exception e)
                        {
                                {if (true) throw new ParseException(e.toString());}
                        }
      }
    } else {
      ;
    }
    jj_consume_token(RBRACE);
        {if (true) return subField;}
    throw new Error("Missing return statement in function");
  }

  final public String SubFieldGroupName() throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
        {if (true) return t.image;}
      break;
    case QSTRING_LITERAL:
      t = jj_consume_token(QSTRING_LITERAL);
        {if (true) return t.image.substring(1, t.image.length()-1);}
      break;
    default:
      jj_la1[40] = jj_gen;
        {if (true) return "";}
    }
    throw new Error("Missing return statement in function");
  }

  final public List<FilterInterval> FilterIntervals(DataValueType type) throws ParseException {
        List<FilterInterval> filterIntervals = new ArrayList<FilterInterval>();
        FilterInterval       filterInterval  = null;
    filterInterval = FilterInterval(type);
                filterIntervals.add(filterInterval);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[41] = jj_gen;
        break label_18;
      }
      jj_consume_token(COMMA);
      filterInterval = FilterInterval(type);
                    filterIntervals.add(filterInterval);
    }
                {if (true) return filterIntervals;}
    throw new Error("Missing return statement in function");
  }

  final public FilterInterval FilterInterval(DataValueType type) throws ParseException {
        FilterInterval filterInterval = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
    case LBRACKET:
      filterInterval = MathsNotation(type);
      break;
    case MINUS:
    case INTEGER:
    case REAL:
    case HEXNUM:
    case IDENTIFIER:
    case QSTRING_LITERAL:
      filterInterval = ShorthandNotation(type);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return filterInterval;}
    throw new Error("Missing return statement in function");
  }

  final public FilterInterval MathsNotation(DataValueType type) throws ParseException {
        FilterInterval filterInterval = null;

        boolean lowerClosed = true;
        boolean upperClosed = true;

        DataValue lowerBoundVal = null;
        DataValue upperBoundVal = null;
    lowerClosed = LowerBound();
    lowerBoundVal = BoundaryValue(type);
    jj_consume_token(COMMA);
    upperBoundVal = BoundaryValue(type);
    upperClosed = UpperBound();
                try
                {
                    if (lowerBoundVal != null && upperBoundVal != null)
                    {
                        if (lowerBoundVal.equals(upperBoundVal))
                        {
                    filterInterval = new FilterIntervalDegenerateBounded(lowerClosed,
                                                                                     upperClosed,
                                                                                     lowerBoundVal,
                                                                                     upperBoundVal);
                        }
                        else
                        {
                    filterInterval = new FilterIntervalNonDegenerateBounded(lowerClosed,
                                                                                        upperClosed,
                                                                                        lowerBoundVal,
                                                                                        upperBoundVal);
                        }
                    }
                    else
                    {
                            filterInterval = new FilterIntervalUnbounded(lowerClosed,
                                                                         upperClosed,
                                                                         lowerBoundVal,
                                                                         upperBoundVal);
                    }
                }
                catch (Exception e)
                {
                        {if (true) throw new ParseException(e.toString());}
                }

            {if (true) return filterInterval;}
    throw new Error("Missing return statement in function");
  }

  final public FilterInterval ShorthandNotation(DataValueType type) throws ParseException {
        FilterInterval filterInterval = null;

        DataValue lowerBoundVal = null;
        DataValue upperBoundVal = null;
    if (jj_2_4(2)) {
      lowerBoundVal = BoundaryValue(type);
      jj_consume_token(MINUS);
      upperBoundVal = BoundaryValue(type);
                        try
                        {
                            if (lowerBoundVal != null && upperBoundVal != null)
                            {
                                filterInterval = new FilterIntervalNonDegenerateBounded(true,
                                                                                        true,
                                                                                        lowerBoundVal,
                                                                                        upperBoundVal);
                            }
                            else
                            {
                                filterInterval = new FilterIntervalUnbounded(lowerBoundVal != null ? true : false,
                                                                             upperBoundVal != null ? true : false,
                                                                             lowerBoundVal,
                                                                             upperBoundVal);
                            }
                    }
                    catch (Exception e)
                    {
                            {if (true) throw new ParseException(e.toString());}
                    }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
      case REAL:
      case HEXNUM:
      case IDENTIFIER:
      case QSTRING_LITERAL:
        lowerBoundVal = NonNullBoundaryValue(type);
                        try
                        {
                            filterInterval = new FilterIntervalDegenerateBounded(true,
                                                                                 true,
                                                                                 lowerBoundVal,
                                                                                 lowerBoundVal);
                    }
                    catch (Exception e)
                    {
                            {if (true) throw new ParseException(e.toString());}
                    }
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                {if (true) return filterInterval;}
    throw new Error("Missing return statement in function");
  }

  final public boolean LowerBound() throws ParseException {
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      t = jj_consume_token(LPAREN);
      break;
    case LBRACKET:
      t = jj_consume_token(LBRACKET);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t.image.equals("[");}
    throw new Error("Missing return statement in function");
  }

  final public boolean UpperBound() throws ParseException {
        Token t = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      t = jj_consume_token(RPAREN);
      break;
    case RBRACKET:
      t = jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return t.image.equals("]");};
    throw new Error("Missing return statement in function");
  }

  final public DataValue BoundaryValue(DataValueType type) throws ParseException {
        DataValue value = null;
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case REAL:
    case HEXNUM:
    case IDENTIFIER:
    case QSTRING_LITERAL:
      value = NonNullBoundaryValue(type);
                {if (true) return value;}
      break;
    default:
      jj_la1[46] = jj_gen;
                {if (true) return null;}
    }
    throw new Error("Missing return statement in function");
  }

  final public DataValue NonNullBoundaryValue(DataValueType type) throws ParseException {
        Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
      t = jj_consume_token(INTEGER);
                {if (true) return DataValueFactory.createDataValue(t.image,
                                                        type == DataValueType.eUnknown ?
                                                                DataValueType.eString :
                                                                type);}
      break;
    case REAL:
      t = jj_consume_token(REAL);
                {if (true) return DataValueFactory.createDataValue(t.image,
                                                        type == DataValueType.eUnknown ?
                                                                DataValueType.eString :
                                                                type);}
      break;
    case HEXNUM:
      t = jj_consume_token(HEXNUM);
                {if (true) return DataValueFactory.createDataValue(t.image,
                                                        type == DataValueType.eUnknown ?
                                                                DataValueType.eString :
                                                                type);}
      break;
    case IDENTIFIER:
      t = jj_consume_token(IDENTIFIER);
                {if (true) return DataValueFactory.createDataValue(t.image,
                                                        type == DataValueType.eUnknown ?
                                                                DataValueType.eString :
                                                                type);}
      break;
    case QSTRING_LITERAL:
      t = jj_consume_token(QSTRING_LITERAL);
                {if (true) return DataValueFactory.createDataValue(t.image.substring(1, t.image.length()-1),
                                                        type == DataValueType.eUnknown ?
                                                                DataValueType.eString :
                                                                type);}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_3R_21() {
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_22()) return true;
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  private boolean jj_3R_28() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    return false;
  }

  private boolean jj_3R_26() {
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(VAR_NAME)) return true;
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(QSTRING_LITERAL)) return true;
    return false;
  }

  private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) return true;
    }
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_3R_30()) return true;
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_20()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_21()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    if (jj_scan_token(HEXNUM)) return true;
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) {
    jj_scanpos = xsp;
    if (jj_3R_24()) return true;
    }
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_scan_token(REAL)) return true;
    return false;
  }

  private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) return true;
    }
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) {
    jj_scanpos = xsp;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) {
    jj_scanpos = xsp;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    }
    }
    }
    return false;
  }

  /** Generated Token Manager. */
  public FieldValueExpressionParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  private int jj_gen;
  final private int[] jj_la1 = new int[48];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x4000000,0x20000,0x40000,0x20,0x40,0x80,0x180000,0x1e00000,0x300,0xc00,0x7000,0x8000,0x2010c00,0x0,0x0,0x2010c00,0x0,0x0,0xc00,0xf0000000,0x180000,0x1e00000,0x7000,0x300,0x2010c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000,0x2000000,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfe0080,0x1000,0xfe0080,0x80,0xbe0080,0x0,0x7f,0x0,0x0,0x0,0x0,0x0,0xe0000,0x800,0x800,0x8000,0x1000,0x902000,0x80,0x8000,0x1000,0x902000,0x80,0x0,0x0,0x1000,0x900000,0x1000,0x9e8080,0x9e0000,0x8080,0x10100,0x9e0000,0x9e0000,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[4];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public FieldValueExpressionParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public FieldValueExpressionParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new FieldValueExpressionParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public FieldValueExpressionParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new FieldValueExpressionParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public FieldValueExpressionParser(FieldValueExpressionParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(FieldValueExpressionParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[56];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 48; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 56; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 4; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
